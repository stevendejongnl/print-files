name: Generate G-code from STL files

on:
  push:
    paths:
      - '**/*.stl'
      - 'profiles/*.cfg'
      - 'profiles/*.curaprofile'
  workflow_dispatch:
    inputs:
      profile:
        description: 'Filament profile to use'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - pla-plus
          - petg
          - petg-cf

permissions:
  contents: write

jobs:
  generate-gcode:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache Cura AppImage
        uses: actions/cache@v4
        with:
          path: /tmp/UltiMaker-Cura-5.9.0-linux-X64.AppImage
          key: cura-appimage-5.9.0

      - name: Install CuraEngine
        id: cura
        run: |
          echo "Setting up CuraEngine from Cura AppImage..."

          CURA_VERSION="5.9.0"
          APPIMAGE="UltiMaker-Cura-${CURA_VERSION}-linux-X64.AppImage"
          APPIMAGE_PATH="/tmp/${APPIMAGE}"

          # Install patchelf for fixing ELF interpreter
          echo "Installing patchelf..."
          sudo apt-get update -qq && sudo apt-get install -y -qq patchelf >/dev/null 2>&1

          # Download AppImage if not cached
          if [ ! -f "$APPIMAGE_PATH" ]; then
            echo "Downloading Cura ${CURA_VERSION} AppImage..."
            curl -sL "https://github.com/Ultimaker/Cura/releases/download/${CURA_VERSION}/${APPIMAGE}" \
              -o "$APPIMAGE_PATH"
            chmod +x "$APPIMAGE_PATH"
          else
            echo "Using cached Cura AppImage"
          fi

          # Extract AppImage
          echo "Extracting CuraEngine and definitions..."
          cd /tmp && "$APPIMAGE_PATH" --appimage-extract >/dev/null 2>&1

          # Locate CuraEngine binary
          CURA_ENGINE=$(find /tmp/squashfs-root -name "CuraEngine" -type f | head -1)
          if [ -z "$CURA_ENGINE" ]; then
            echo "Error: CuraEngine binary not found in AppImage"
            exit 1
          fi
          chmod +x "$CURA_ENGINE"
          echo "Found CuraEngine at: $CURA_ENGINE"

          # Fix ELF interpreter using patchelf
          echo "Fixing ELF interpreter with patchelf..."
          patchelf --set-interpreter /lib64/ld-linux-x86-64.so.2 "$CURA_ENGINE"
          echo "ELF interpreter patched successfully"

          # Find all lib directories in the AppImage for comprehensive LD_LIBRARY_PATH
          echo "Building comprehensive library path..."
          LIB_PATHS="/tmp/squashfs-root/lib:/tmp/squashfs-root/lib64:/tmp/squashfs-root/usr/lib:/tmp/squashfs-root/usr/lib/x86_64-linux-gnu:/tmp/squashfs-root/usr/lib/i386-linux-gnu"
          for libdir in $(find /tmp/squashfs-root -type d -name "lib*" 2>/dev/null | head -20); do
            LIB_PATHS="$LIB_PATHS:$libdir"
          done

          # Create wrapper script with comprehensive library setup
          echo "Creating CuraEngine wrapper script..."
          cat > /tmp/run-curaengine.sh << EOF
          #!/bin/bash
          export LD_LIBRARY_PATH="$LIB_PATHS:\$LD_LIBRARY_PATH"
          export QT_PLUGIN_PATH="/tmp/squashfs-root/usr/lib/x86_64-linux-gnu/qt5/plugins:/tmp/squashfs-root/usr/lib/qt5/plugins"
          export QT_QPA_PLATFORM_PLUGIN_PATH="/tmp/squashfs-root/usr/lib/x86_64-linux-gnu/qt5/plugins"
          export PATH="/tmp/squashfs-root/usr/bin:\$PATH"
          exec "$CURA_ENGINE" "\$@"
          EOF
          chmod +x /tmp/run-curaengine.sh
          echo "Wrapper script created successfully with comprehensive library paths"

          # Get definitions from AppImage
          DEFS_FILE=$(find /tmp/squashfs-root -name "fdmprinter.def.json" -type f 2>/dev/null | head -1)
          if [ ! -f "$DEFS_FILE" ]; then
            echo "Error: fdmprinter.def.json not found in AppImage"
            exit 1
          fi
          DEFS_DIR=$(dirname "$DEFS_FILE")
          echo "Found definitions: $DEFS_DIR"

          {
            echo "engine=/tmp/run-curaengine.sh"
            echo "definition=$DEFS_FILE"
            echo "search_path=$DEFS_DIR"
          } >> "$GITHUB_OUTPUT"

      - name: Determine profiles
        id: profiles
        env:
          PROFILE_INPUT: ${{ github.event.inputs.profile }}
        run: |
          SELECTION="${PROFILE_INPUT:-all}"
          if [ "$SELECTION" = "all" ]; then
            # Collect all .cfg profile names
            PROFILES=""
            for cfg in profiles/*.cfg; do
              name=$(basename "$cfg" .cfg)
              PROFILES="${PROFILES:+$PROFILES }$name"
            done
          else
            PROFILES="$SELECTION"
          fi
          echo "list=$PROFILES" >> "$GITHUB_OUTPUT"
          echo "Profiles to generate: $PROFILES"

      - name: Generate G-code files
        env:
          PROFILES: ${{ steps.profiles.outputs.list }}
          CURA_ENGINE: ${{ steps.cura.outputs.engine }}
          DEFINITION: ${{ steps.cura.outputs.definition }}
          CURA_ENGINE_SEARCH_PATH: ${{ steps.cura.outputs.search_path }}
        run: |
          TOTAL_GENERATED=0
          TOTAL_FAILED=0

          # shellcheck disable=SC2153
          for PROFILE in $PROFILES; do
            echo "========================================"
            echo "Profile: $PROFILE"
            echo "========================================"

            PROFILE_FILE="profiles/${PROFILE}.cfg"

            if [ ! -f "$PROFILE_FILE" ]; then
              echo "Warning: Profile not found: $PROFILE_FILE, skipping"
              continue
            fi

            echo "Definition: $DEFINITION"
            echo "Search path: $CURA_ENGINE_SEARCH_PATH"
            echo ""

            # Build settings arguments array from profile
            SETTINGS_ARGS=()
            while IFS= read -r line; do
              # Remove comments and trim whitespace
              line="${line%%#*}"
              line="$(echo "$line" | xargs)"
              if [ -z "$line" ]; then
                continue
              fi
              if [[ "$line" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)\ *=\ *(.+)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="$(echo "${BASH_REMATCH[2]}" | xargs)"
                SETTINGS_ARGS+=("-s" "${key}=${value}")
              fi
            done < "$PROFILE_FILE"

            echo "Loaded ${#SETTINGS_ARGS[@]} setting arguments"
            echo ""

            # Find and process all STL files
            while IFS= read -r stl_file; do
              echo "Processing: $stl_file"

              dir=$(dirname "$stl_file")
              base=$(basename "$stl_file" .stl)
              gcode_file="$dir/$base.$PROFILE.gcode"

              echo "  Generating G-code: $gcode_file"

              if "$CURA_ENGINE" slice \
                -j "$DEFINITION" \
                "${SETTINGS_ARGS[@]}" \
                -l "$stl_file" \
                -o "$gcode_file" 2>&1; then
                if [ -f "$gcode_file" ] && [ -s "$gcode_file" ]; then
                  echo "  Generated successfully ($(du -h "$gcode_file" | cut -f1))"
                  TOTAL_GENERATED=$((TOTAL_GENERATED + 1))
                else
                  echo "  Warning: G-code file empty or missing"
                  rm -f "$gcode_file"
                  TOTAL_FAILED=$((TOTAL_FAILED + 1))
                fi
              else
                echo "  Error: CuraEngine failed for $stl_file"
                rm -f "$gcode_file"
                TOTAL_FAILED=$((TOTAL_FAILED + 1))
              fi

              echo ""
            done < <(find . -name "*.stl" -not -path "./.git/*" -not -path "./docs/*" | sort)

          done

          echo "========================================"
          echo "Summary: $TOTAL_GENERATED generated, $TOTAL_FAILED failed"
          echo "========================================"
          if [ "$TOTAL_GENERATED" -eq 0 ] && [ "$TOTAL_FAILED" -gt 0 ]; then
            echo "Error: All STL files failed to generate G-code"
            exit 1
          fi

      - name: Check for changes
        id: check-changes
        run: |
          # Add all generated G-code files using find for reliable matching
          find . -name '*.gcode' -not -path './.git/*' -not -path './docs/*' \
            -exec git add {} +

          if git diff --cached --quiet; then
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            echo "No G-code changes detected"
          else
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            echo "G-code changes detected:"
            git diff --cached --name-only
          fi

      - name: Commit and push generated files
        if: steps.check-changes.outputs.has_changes == 'true'
        env:
          PROFILES: ${{ steps.profiles.outputs.list }}
          REF_NAME: ${{ github.ref_name }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          echo "Files to be committed:"
          git diff --cached --name-only

          changed_files=$(git diff --cached --name-only | tr '\n' ', ' | sed 's/,$//')

          printf "%s\n\n%s\n%s\n\n%s" \
            "Auto-generate G-code from STL files" \
            "Profiles: $PROFILES" \
            "Generated files: $changed_files" \
            "[skip ci]" > /tmp/commit-msg

          git commit -F /tmp/commit-msg

          echo "Pushing changes to $REF_NAME..."
          git push origin "HEAD:$REF_NAME"
